# Правила разработки osury

Этот файл содержит инварианты проекта — правила, которые нельзя нарушать ни при каких обстоятельствах. Каждое правило проверено практикой и защищает от конкретных классов ошибок.

---

## Правило 1. Единый конвейер

Весь код проходит строгий конвейер:

```
OpenAPI JSON → Schema.parse → SchemaAST → Codegen.generateModule → ReScript code
                                  ↑
                        OpenAPIParser.parseDocument
                        (извлекает schemas из документа)
```

Нельзя генерировать ReScript-код напрямую из JSON. Codegen.res работает только с `Schema.schemaType`, никогда с `JSON.t` или `Dict.t<JSON.t>`.

**Почему:** Если Codegen начнёт парсить JSON, мы потеряем единую точку валидации, и ошибки станут непредсказуемыми.

---

## Правило 2. SchemaAST — единственный источник истины

Тип `Schema.schemaType` определяет всё, что компилятор умеет обрабатывать. Новая OpenAPI-конструкция поддерживается тогда и только тогда, когда она выражена в `schemaType`.

Текущие варианты (14):
```
String | Number | Integer | Boolean | Null
| Optional(schemaType) | Nullable(schemaType)
| Object(array<field>) | Array(schemaType)
| Ref(string) | Enum(array<string>)
| PolyVariant(array<variantCase>)
| Dict(schemaType) | Union(array<schemaType>)
```

**При добавлении нового варианта** — обязательно обновить всех потребителей (см. Правило 3).

---

## Правило 3. Exhaustive pattern-match

При добавлении нового варианта в `schemaType` нужно обновить ВСЕ функции, которые делают `switch` по этому типу. Неполный pattern-match — блокирующая ошибка.

### Список потребителей schemaType

**Schema.res** (парсинг):
- Возвращает `schemaType` — нужно добавить парсинг нового варианта

**Codegen.res** (генерация):
- `generateType` — генерация ReScript-типа
- `isOptionalType` — проверка на Optional/Nullable обёртку
- `isNullableType` — проверка на Nullable
- `hasUnion` — рекурсивный поиск Union в дереве типов
- `getTagForType` — имя тега для poly variant
- `extractUnionsFromType` — извлечение Union для выделения в отдельный тип
- `replaceUnionInType` — замена Union на Ref после извлечения
- `getDependencies` — сбор Ref-зависимостей для топологической сортировки
- `generateRecord` — генерация полей записи (если тип используется как поле)

**Errors.res:**
- Может потребовать новый `errorKind` для ошибок парсинга нового варианта

**bin/osury.mjs:**
- CLI обычно не требует изменений (работает через generateModule), но проверить вывод

**Чеклист добавления нового варианта:**
1. [ ] Добавить вариант в `schemaType` (Schema.res)
2. [ ] Реализовать парсинг из JSON (Schema.res)
3. [ ] Добавить генерацию ReScript-кода (Codegen.generateType)
4. [ ] Обновить рекурсивные обходы: hasUnion, extractUnionsFromType, replaceUnionInType, getDependencies, getTagForType
5. [ ] Добавить тест парсинга + тест генерации кода
6. [ ] Проверить что `npm run res:build` проходит без warnings
7. [ ] Проверить что сгенерированный код компилируется ReScript-ом

---

## Правило 4. Результат вместо исключений

Все функции парсинга возвращают `result<T, Errors.errors>`. Исключения запрещены в логике компилятора.

```rescript
// Правильно:
let parse: JSON.t => result<schemaType, errors>

// Запрещено:
let parse: JSON.t => schemaType  // может бросить исключение
```

Ошибки накапливаются: парсер не останавливается на первой ошибке, а собирает все и возвращает массив.

---

## Правило 5. Структурированные ошибки с location

Каждая ошибка содержит:
- `kind: errorKind` — что именно сломалось (типизированный вариант, не строка)
- `location: { path, line, column }` — где сломалось
- `hint: option<string>` — как починить (когда возможно)

**Нельзя** создавать ошибки со строковым сообщением без структуры. Для каждого нового класса ошибки — добавить вариант в `errorKind`.

---

## Правило 6. Трансформации до генерации кода

Codegen.generateModule выполняет трансформации в определённом порядке. Этот порядок менять нельзя:

```
1. collectUnionWarnings  — диагностика проблемных union-паттернов
2. extractUnions         — извлечение inline Union в отдельные именованные типы
3. deduplicate           — дедупликация по структурному имени
4. replaceUnions         — замена inline Union на Ref(extractedName)
5. buildSchemasDict      — словарь для inline record lookups
6. topologicalSort       — Кahn's algorithm для порядка определений
7. generateTypeDefWithSkipSet — генерация ReScript-кода
```

**Почему:** Union extraction должен быть до topological sort, иначе зависимости от извлечённых типов не будут учтены. Генерация должна быть последней, потому что она только печатает — не трансформирует.

---

## Правило 7. @schema совместимость

Аннотация `@schema` (sury-ppx) генерируется для типа, только если тип совместим с sury-ppx:
- Inline Union-ы **несовместимы** с @schema → поэтому они извлекаются в отдельные типы (Правило 6)
- Извлечённые Union-типы получают `@tag("_tag")` + `@schema`
- Примитивные union-ы (`String | Number`) дополнительно получают `@unboxed`

**Нельзя** ставить `@schema` на тип, пока не проверена совместимость с sury-ppx.

---

## Правило 8. Аннотации генерируемого кода

Каждый сгенерированный тип обязательно получает:
- `@genType` — для генерации TypeScript-типов
- `@schema` — для генерации Sury-схем (если совместим, см. Правило 7)

Variant-типы дополнительно получают:
- `@tag("_tag")` — дискриминант в стиле Effect TS (не стандартный `TAG`)

**Никогда** не менять дискриминант с `_tag` на что-то другое — это ключевое решение для Effect TS совместимости.

---

## Правило 9. Порядок типов в выходном файле

Типы определяются в порядке топологической сортировки: тип X должен быть определён ДО типов, которые на него ссылаются через `Ref(X)`.

Для циклических зависимостей (circular refs) — типы добавляются в конец. На данный момент circular refs не поддерживаются полноценно и должны давать явную диагностику, а не молча ломаться.

---

## Правило 10. Reserved keywords

Если имя поля JSON совпадает с ключевым словом ReScript (type, let, module и т.д.), генератор обязан:
1. Использовать `@as("originalName")` атрибут
2. Добавить суффикс `_` к имени поля: `type_` вместо `type`

Список ключевых слов определён в `Codegen.reservedKeywords` и должен обновляться при обновлении версии ReScript.

---

## Правило 11. Тесты — часть контракта

Каждый поддерживаемый OpenAPI-конструкт покрыт минимум двумя тестами:
1. **Тест парсинга:** JSON → SchemaAST (проверяет структуру AST)
2. **Тест генерации:** SchemaAST → ReScript code (проверяет строку выхода)

Для сложных паттернов (union extraction, deduplication, topological sort) — отдельные тесты трансформаций.

**TDD-правило:** один тест за раз. Написать тест → красный → реализовать → зелёный → commit.

---

## Правило 12. _tag фильтрация

Поле `_tag` в JSON Schema **всегда** пропускается при парсинге properties объекта. Оно обрабатывается через `@tag("_tag")` аннотацию на уровне variant-типа, а не как обычное поле записи.

Это относится к:
- `parseObjectType` в Schema.res (фильтрация `_tag` из properties)
- `parseOneOf` в Schema.res (извлечение `_tag.const` как дискриминатора, остальные properties как payload)

---

## Правило 13. Shim-файлы генерируются вместе с основным кодом

CLI (`bin/osury.mjs`) генерирует не только основной `.res` файл, но и обязательные shim-ы:
- `Dict.gen.ts` — TypeScript-тип для `Dict.t<T>`
- `Nullable.res` — ReScript-модуль для `Nullable.t<'a> = option<'a>`
- `Nullable.shim.ts` — TypeScript-маппинг `t<T> = T | null`

**Нельзя** генерировать `.res` файл без shim-ов, если в схеме используются Dict или Nullable типы.

---

## Checklist перед merge

Проверяется при каждом изменении:

1. [ ] **Конвейер:** Новая функциональность выражена через SchemaAST, Codegen не парсит JSON напрямую
2. [ ] **Pattern-match:** Все потребители `schemaType` обновлены (см. список в Правиле 3)
3. [ ] **Тесты:** Добавлен тест парсинга И тест генерации для нового конструкта
4. [ ] **Сборка:** `npm run res:build` проходит без warnings
5. [ ] **Тесты зелёные:** `npm test` проходит полностью
6. [ ] **Выход компилируется:** Сгенерированный `.res` файл компилируется ReScript-ом (проверить на `openapi.json`)
7. [ ] **Shim-ы актуальны:** Если добавлены новые TypeScript-шимы, они включены в `package.json` files
8. [ ] **Ошибки информативны:** Новые ошибочные пути дают структурированную диагностику (kind + location + hint)
