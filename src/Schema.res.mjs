// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Errors from "./Errors.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function isNullType(json) {
  if (typeof json !== "object" || json === null || Array.isArray(json)) {
    return false;
  }
  let match = json["type"];
  return match === "null";
}

function extractRefName(refPath) {
  let parts = refPath.split("/");
  return Core__Option.getOr(parts[parts.length - 1 | 0], refPath);
}

function parseEnumValues(arr) {
  let values = Core__Array.filterMap(arr, item => {
    if (typeof item === "string") {
      return item;
    }
  });
  if (values.length === arr.length) {
    return values;
  }
}

function extractTagFromConst(dict) {
  let match = dict["_tag"];
  if (match === undefined) {
    return;
  }
  if (typeof match !== "object" || match === null || Array.isArray(match)) {
    return;
  }
  let match$1 = match["const"];
  if (typeof match$1 === "string") {
    return match$1;
  }
}

function parseSchema(json) {
  if (typeof json === "object" && json !== null && !Array.isArray(json)) {
    return parseObject(json);
  }
  return {
    TAG: "Error",
    _0: [Errors.makeError({
        TAG: "InvalidJson",
        _0: "expected object"
      }, undefined, undefined, undefined)]
  };
}

function parsePrimitiveType(dict) {
  let match = dict["type"];
  if (match === undefined) {
    return {
      TAG: "Error",
      _0: [Errors.missingField("type", undefined, undefined, undefined)]
    };
  }
  if (typeof match === "string") {
    switch (match) {
      case "array" :
        return parseArrayType(dict);
      case "boolean" :
        return {
          TAG: "Ok",
          _0: "Boolean"
        };
      case "integer" :
        return {
          TAG: "Ok",
          _0: "Integer"
        };
      case "null" :
        return {
          TAG: "Ok",
          _0: "Null"
        };
      case "number" :
        return {
          TAG: "Ok",
          _0: "Number"
        };
      case "object" :
        return parseObjectType(dict);
      case "string" :
        let match$1 = dict["enum"];
        if (match$1 === undefined) {
          return {
            TAG: "Ok",
            _0: "String"
          };
        }
        let exit = 0;
        if (Array.isArray(match$1)) {
          let values = parseEnumValues(match$1);
          if (values !== undefined) {
            return {
              TAG: "Ok",
              _0: {
                _tag: "Enum",
                _0: values
              }
            };
          } else {
            return {
              TAG: "Error",
              _0: [Errors.makeError({
                  TAG: "InvalidJson",
                  _0: "enum values must be strings"
                }, undefined, undefined, undefined)]
            };
          }
        }
        exit = 2;
        if (exit === 2) {
          return {
            TAG: "Error",
            _0: [Errors.makeError({
                TAG: "InvalidJson",
                _0: "enum must be an array"
              }, undefined, undefined, undefined)]
          };
        }
        break;
      default:
        return {
          TAG: "Error",
          _0: [Errors.unknownType(match, undefined, undefined, undefined)]
        };
    }
  }
  return {
    TAG: "Error",
    _0: [Errors.makeError({
        TAG: "InvalidJson",
        _0: "type must be a string"
      }, undefined, undefined, undefined)]
  };
}

function parseArrayType(dict) {
  let itemSchema = dict["items"];
  if (itemSchema === undefined) {
    return {
      TAG: "Error",
      _0: [Errors.missingField("items", undefined, "array type requires items schema", undefined)]
    };
  }
  let itemType = parseSchema(itemSchema);
  if (itemType.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        _tag: "Array",
        _0: itemType._0
      }
    };
  } else {
    return {
      TAG: "Error",
      _0: itemType._0
    };
  }
}

function parseAnyOf(items) {
  if (items.length !== 2) {
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "UnsupportedFeature",
          _0: "anyOf with more than 2 items"
        }, undefined, undefined, undefined)]
    };
  }
  let hasNull = items.some(isNullType);
  if (!hasNull) {
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "UnsupportedFeature",
          _0: "anyOf without null (union types)"
        }, undefined, undefined, undefined)]
    };
  }
  let nonNullItem = items.find(item => !isNullType(item));
  if (nonNullItem === undefined) {
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "InvalidJson",
          _0: "anyOf with only null types"
        }, undefined, undefined, undefined)]
    };
  }
  if (typeof nonNullItem === "object" && nonNullItem !== null && !Array.isArray(nonNullItem)) {
    let innerType = parsePrimitiveType(nonNullItem);
    if (innerType.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          _tag: "Optional",
          _0: innerType._0
        }
      };
    } else {
      return {
        TAG: "Error",
        _0: innerType._0
      };
    }
  }
  return {
    TAG: "Error",
    _0: [Errors.makeError({
        TAG: "InvalidJson",
        _0: "anyOf item must be object"
      }, undefined, undefined, undefined)]
  };
}

function parseObjectType(dict) {
  let valueSchema = dict["additionalProperties"];
  let exit = 0;
  if (valueSchema !== undefined) {
    switch (typeof valueSchema) {
      case "boolean" :
        if (valueSchema) {
          return {
            TAG: "Ok",
            _0: {
              _tag: "Dict",
              _0: "String"
            }
          };
        }
        exit = 1;
        break;
      case "object" :
        let valueType = parseSchema(valueSchema);
        if (valueType.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              _tag: "Dict",
              _0: valueType._0
            }
          };
        } else {
          return {
            TAG: "Error",
            _0: valueType._0
          };
        }
      default:
        exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    let match = dict["required"];
    let requiredFields = match !== undefined ? (
        Array.isArray(match) ? Core__Array.filterMap(match, item => {
            if (typeof item === "string") {
              return item;
            }
          }) : []
      ) : [];
    let match$1 = dict["properties"];
    if (match$1 === undefined) {
      return {
        TAG: "Ok",
        _0: {
          _tag: "Object",
          _0: []
        }
      };
    }
    let exit$1 = 0;
    if (typeof match$1 === "object" && match$1 !== null && !Array.isArray(match$1)) {
      let entries = Object.entries(match$1);
      let results = entries.map(param => {
        let name = param[0];
        let propType = parseSchema(param[1]);
        if (propType.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              name: name,
              type: propType._0,
              required: requiredFields.includes(name)
            }
          };
        } else {
          return {
            TAG: "Error",
            _0: propType._0
          };
        }
      });
      let errors = Core__Array.filterMap(results, r => {
        if (r.TAG === "Ok") {
          return;
        } else {
          return r._0;
        }
      }).flat();
      if (errors.length > 0) {
        return {
          TAG: "Error",
          _0: errors
        };
      }
      let fields = Core__Array.filterMap(results, r => {
        if (r.TAG === "Ok") {
          return r._0;
        }
      });
      return {
        TAG: "Ok",
        _0: {
          _tag: "Object",
          _0: fields
        }
      };
    }
    exit$1 = 2;
    if (exit$1 === 2) {
      return {
        TAG: "Error",
        _0: [Errors.makeError({
            TAG: "InvalidJson",
            _0: "properties must be an object"
          }, undefined, undefined, undefined)]
      };
    }
  }
}

function parseAllOf(items) {
  let results = items.map(parseSchema);
  let errors = Core__Array.filterMap(results, r => {
    if (r.TAG === "Ok") {
      return;
    } else {
      return r._0;
    }
  }).flat();
  if (errors.length > 0) {
    return {
      TAG: "Error",
      _0: errors
    };
  }
  let allFields = Core__Array.filterMap(results, r => {
    if (r.TAG !== "Ok") {
      return;
    }
    let fields = r._0;
    if (typeof fields !== "object" || fields._tag !== "Object") {
      return;
    } else {
      return fields._0;
    }
  }).flat();
  return {
    TAG: "Ok",
    _0: {
      _tag: "Object",
      _0: allFields
    }
  };
}

function parseOneOf(items) {
  let caseResults = items.map(item => {
    if (typeof item === "object" && item !== null && !Array.isArray(item)) {
      let match = item["properties"];
      let exit = 0;
      if (match !== undefined) {
        if (typeof match === "object" && match !== null && !Array.isArray(match)) {
          let tag = extractTagFromConst(match);
          if (tag === undefined) {
            return {
              TAG: "Error",
              _0: [Errors.makeError({
                  TAG: "MissingRequiredField",
                  _0: "_tag with const"
                }, undefined, undefined, undefined)]
            };
          }
          let match$1 = item["required"];
          let requiredFields = match$1 !== undefined ? (
              Array.isArray(match$1) ? Core__Array.filterMap(match$1, i => {
                  if (typeof i === "string") {
                    return i;
                  }
                }) : []
            ) : [];
          let entries = Object.entries(match).filter(param => param[0] !== "_tag");
          let fieldResults = entries.map(param => {
            let name = param[0];
            let propType = parseSchema(param[1]);
            if (propType.TAG === "Ok") {
              return {
                TAG: "Ok",
                _0: {
                  name: name,
                  type: propType._0,
                  required: requiredFields.includes(name)
                }
              };
            } else {
              return {
                TAG: "Error",
                _0: propType._0
              };
            }
          });
          let errors = Core__Array.filterMap(fieldResults, r => {
            if (r.TAG === "Ok") {
              return;
            } else {
              return r._0;
            }
          }).flat();
          if (errors.length > 0) {
            return {
              TAG: "Error",
              _0: errors
            };
          }
          let fields = Core__Array.filterMap(fieldResults, r => {
            if (r.TAG === "Ok") {
              return r._0;
            }
          });
          return {
            TAG: "Ok",
            _0: {
              _tag: tag,
              payload: {
                _tag: "Object",
                _0: fields
              }
            }
          };
        }
        exit = 2;
      } else {
        exit = 2;
      }
      if (exit === 2) {
        return {
          TAG: "Error",
          _0: [Errors.makeError({
              TAG: "InvalidJson",
              _0: "oneOf item must have properties"
            }, undefined, undefined, undefined)]
        };
      }
    }
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "InvalidJson",
          _0: "oneOf item must be object"
        }, undefined, undefined, undefined)]
    };
  });
  let errors = Core__Array.filterMap(caseResults, r => {
    if (r.TAG === "Ok") {
      return;
    } else {
      return r._0;
    }
  }).flat();
  if (errors.length > 0) {
    return {
      TAG: "Error",
      _0: errors
    };
  }
  let cases = Core__Array.filterMap(caseResults, r => {
    if (r.TAG === "Ok") {
      return r._0;
    }
  });
  return {
    TAG: "Ok",
    _0: {
      _tag: "PolyVariant",
      _0: cases
    }
  };
}

function parseObject(dict) {
  let match = dict["$ref"];
  if (match !== undefined) {
    if (typeof match === "string") {
      return {
        TAG: "Ok",
        _0: {
          _tag: "Ref",
          _0: extractRefName(match)
        }
      };
    }
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "InvalidJson",
          _0: "$ref must be a string"
        }, undefined, undefined, undefined)]
    };
  }
  let match$1 = dict["oneOf"];
  if (match$1 !== undefined) {
    if (Array.isArray(match$1)) {
      return parseOneOf(match$1);
    }
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "InvalidJson",
          _0: "oneOf must be an array"
        }, undefined, undefined, undefined)]
    };
  }
  let match$2 = dict["allOf"];
  if (match$2 !== undefined) {
    if (Array.isArray(match$2)) {
      return parseAllOf(match$2);
    }
    return {
      TAG: "Error",
      _0: [Errors.makeError({
          TAG: "InvalidJson",
          _0: "allOf must be an array"
        }, undefined, undefined, undefined)]
    };
  }
  let match$3 = dict["anyOf"];
  if (match$3 === undefined) {
    return parsePrimitiveType(dict);
  }
  if (Array.isArray(match$3)) {
    return parseAnyOf(match$3);
  }
  return {
    TAG: "Error",
    _0: [Errors.makeError({
        TAG: "InvalidJson",
        _0: "anyOf must be an array"
      }, undefined, undefined, undefined)]
  };
}

let parse = parseSchema;

export {
  isNullType,
  extractRefName,
  parseEnumValues,
  extractTagFromConst,
  parseSchema,
  parsePrimitiveType,
  parseArrayType,
  parseAnyOf,
  parseObjectType,
  parseAllOf,
  parseOneOf,
  parseObject,
  parse,
}
/* No side effect */
