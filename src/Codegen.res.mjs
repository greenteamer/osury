// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

let reservedKeywords = [
  "type",
  "let",
  "rec",
  "and",
  "as",
  "open",
  "include",
  "module",
  "sig",
  "struct",
  "exception",
  "external",
  "if",
  "else",
  "switch",
  "while",
  "for",
  "try",
  "catch",
  "when",
  "true",
  "false",
  "assert",
  "lazy",
  "constraint",
  "functor",
  "class",
  "method",
  "object",
  "private",
  "public",
  "virtual",
  "mutable",
  "new",
  "inherit",
  "initializer",
  "val",
  "with",
  "match",
  "of",
  "fun",
  "function",
  "in",
  "do",
  "done",
  "begin",
  "end",
  "then",
  "to",
  "downto",
  "or",
  "land",
  "lor",
  "lxor",
  "lsl",
  "lsr",
  "asr",
  "mod",
  "await",
  "async"
];

function isReservedKeyword(name) {
  return reservedKeywords.includes(name);
}

function lcFirst(s) {
  if (s.length === 0) {
    return s;
  }
  let first = s.charAt(0).toLowerCase();
  let rest = s.slice(1);
  return first + rest;
}

function generateType(schema) {
  if (typeof schema !== "object") {
    switch (schema) {
      case "String" :
        return "string";
      case "Number" :
        return "float";
      case "Integer" :
        return "int";
      case "Boolean" :
        return "bool";
      case "Null" :
        return "unit";
    }
  } else {
    switch (schema._tag) {
      case "Optional" :
        return `option<` + generateType(schema._0) + `>`;
      case "Object" :
        return generateRecord(schema._0);
      case "Array" :
        return `array<` + generateType(schema._0) + `>`;
      case "Ref" :
        return lcFirst(schema._0);
      case "Enum" :
        let variants = schema._0.map(v => `#` + v).join(" | ");
        return `[` + variants + `]`;
      case "PolyVariant" :
        return generatePolyVariant(schema._0);
      case "Dict" :
        return `Dict.t<` + generateType(schema._0) + `>`;
      case "Union" :
        return generateUnion(schema._0);
    }
  }
}

function isOptionalType(schema) {
  if (typeof schema !== "object") {
    return false;
  } else {
    return schema._tag === "Optional";
  }
}

function generateRecord(fields) {
  if (fields.length === 0) {
    return "{}";
  }
  let fieldStrs = fields.map(field => {
    let typeStr = generateType(field.type);
    let optionalType = field.required || isOptionalType(field.type) ? typeStr : `option<` + typeStr + `>`;
    if (reservedKeywords.includes(field.name)) {
      return `@as("` + field.name + `") ` + field.name + `_: ` + optionalType;
    } else {
      return field.name + `: ` + optionalType;
    }
  });
  return `{\n  ` + fieldStrs.join(",\n  ") + `\n}`;
}

function generatePolyVariant(cases) {
  let caseStrs = cases.map(c => {
    let payloadStr = generateType(c.payload);
    return `#` + c._tag + `(` + payloadStr + `)`;
  });
  return `[` + caseStrs.join(" | ") + `]`;
}

function ucFirst(s) {
  if (s.length === 0) {
    return s;
  }
  let first = s.charAt(0).toUpperCase();
  let rest = s.slice(1);
  return first + rest;
}

function getTagForType(t) {
  if (typeof t !== "object") {
    switch (t) {
      case "String" :
        return "String";
      case "Number" :
        return "Float";
      case "Integer" :
        return "Int";
      case "Boolean" :
        return "Bool";
      case "Null" :
        return "Null";
    }
  } else {
    switch (t._tag) {
      case "Optional" :
        return `Option` + getTagForType(t._0);
      case "Object" :
        return "Object";
      case "Array" :
        return `Array` + getTagForType(t._0);
      case "Ref" :
        return ucFirst(t._0);
      case "Enum" :
        return "Enum";
      case "PolyVariant" :
        return "Variant";
      case "Dict" :
        return "Dict";
      case "Union" :
        return "Union";
    }
  }
}

function generateUnion(types) {
  let caseStrs = types.map(t => {
    let tag = getTagForType(t);
    let payload = generateType(t);
    return `#` + tag + `(` + payload + `)`;
  });
  return `[` + caseStrs.join(" | ") + `]`;
}

function hasUnion(_schema) {
  while (true) {
    let schema = _schema;
    if (typeof schema !== "object") {
      return false;
    }
    switch (schema._tag) {
      case "Object" :
        return schema._0.some(f => hasUnion(f.type));
      case "PolyVariant" :
        return schema._0.some(c => hasUnion(c.payload));
      case "Optional" :
      case "Array" :
      case "Dict" :
        _schema = schema._0;
        continue;
      case "Union" :
        return true;
      default:
        return false;
    }
  };
}

function getDependencies(_schema) {
  while (true) {
    let schema = _schema;
    if (typeof schema !== "object") {
      return [];
    }
    switch (schema._tag) {
      case "Object" :
        return schema._0.flatMap(f => getDependencies(f.type));
      case "Ref" :
        return [schema._0];
      case "Enum" :
        return [];
      case "PolyVariant" :
        return schema._0.flatMap(c => getDependencies(c.payload));
      case "Optional" :
      case "Array" :
      case "Dict" :
        _schema = schema._0;
        continue;
      case "Union" :
        return schema._0.flatMap(getDependencies);
    }
  };
}

function topologicalSort(schemas) {
  let schemaMap = {};
  schemas.forEach(s => {
    schemaMap[s.name] = s;
  });
  let deps = {};
  schemas.forEach(s => {
    let refNames = getDependencies(s.schema);
    let validRefs = refNames.filter(name => Core__Option.isSome(schemaMap[name]));
    deps[s.name] = validRefs;
  });
  let outDegree = {};
  schemas.forEach(s => {
    let myDeps = Core__Option.getOr(deps[s.name], []);
    outDegree[s.name] = myDeps.length;
  });
  let reverseDeps = {};
  schemas.forEach(s => {
    reverseDeps[s.name] = [];
  });
  Object.entries(deps).forEach(param => {
    let name = param[0];
    param[1].forEach(refName => {
      let arr = reverseDeps[refName];
      if (arr !== undefined) {
        arr.push(name);
        return;
      }
    });
  });
  let queue = schemas.filter(s => Core__Option.getOr(outDegree[s.name], 0) === 0).map(s => s.name);
  let result = [];
  let visited = {};
  let process = () => {
    while (true) {
      let name = queue.shift();
      if (name === undefined) {
        return;
      }
      if (Core__Option.isNone(visited[name])) {
        visited[name] = true;
        let schema = schemaMap[name];
        if (schema !== undefined) {
          result.push(schema);
        }
        let dependents = reverseDeps[name];
        if (dependents !== undefined) {
          dependents.forEach(depName => {
            let current = Core__Option.getOr(outDegree[depName], 0);
            outDegree[depName] = current - 1 | 0;
            if ((current - 1 | 0) === 0) {
              queue.push(depName);
              return;
            }
          });
        }
      }
      continue;
    };
  };
  process();
  schemas.forEach(s => {
    if (Core__Option.isNone(visited[s.name])) {
      result.push(s);
      return;
    }
  });
  return result;
}

function buildSkipSchemaSet(schemas) {
  let skipSet = {};
  schemas.forEach(s => {
    if (hasUnion(s.schema)) {
      skipSet[s.name] = true;
      return;
    }
  });
  let changed = {
    contents: true
  };
  while (changed.contents) {
    changed.contents = false;
    schemas.forEach(s => {
      if (!Core__Option.isNone(skipSet[s.name])) {
        return;
      }
      let refs = getDependencies(s.schema);
      let refsSkipSchema = refs.some(refName => Core__Option.isSome(skipSet[refName]));
      if (refsSkipSchema) {
        skipSet[s.name] = true;
        changed.contents = true;
        return;
      }
    });
  };
  return skipSet;
}

function generateTypeDefWithSkipSet(namedSchema, skipSet) {
  let typeName = lcFirst(namedSchema.name);
  let typeBody = generateType(namedSchema.schema);
  let shouldSkip = Core__Option.isSome(skipSet[namedSchema.name]);
  let annotations = shouldSkip ? "@genType" : "@genType\n@schema";
  return annotations + `
type ` + typeName + ` = ` + typeBody;
}

function generateTypeDef(namedSchema) {
  let annotations = hasUnion(namedSchema.schema) ? "@genType" : "@genType\n@schema";
  let typeName = lcFirst(namedSchema.name);
  let typeBody = generateType(namedSchema.schema);
  return annotations + `
type ` + typeName + ` = ` + typeBody;
}

function generateModule(schemas) {
  let sorted = topologicalSort(schemas);
  let skipSet = buildSkipSchemaSet(schemas);
  return sorted.map(s => generateTypeDefWithSkipSet(s, skipSet)).join("\n\n");
}

export {
  reservedKeywords,
  isReservedKeyword,
  lcFirst,
  generateType,
  isOptionalType,
  generateRecord,
  generatePolyVariant,
  ucFirst,
  getTagForType,
  generateUnion,
  hasUnion,
  getDependencies,
  topologicalSort,
  buildSkipSchemaSet,
  generateTypeDefWithSkipSet,
  generateTypeDef,
  generateModule,
}
/* No side effect */
