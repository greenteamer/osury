// Generated by ReScript, PLEASE EDIT WITH CARE


function lcFirst(s) {
  if (s.length === 0) {
    return s;
  }
  let first = s.charAt(0).toLowerCase();
  let rest = s.slice(1);
  return first + rest;
}

function generateType(schema) {
  if (typeof schema !== "object") {
    switch (schema) {
      case "String" :
        return "string";
      case "Number" :
        return "float";
      case "Integer" :
        return "int";
      case "Boolean" :
        return "bool";
      case "Null" :
        return "unit";
    }
  } else {
    switch (schema._tag) {
      case "Optional" :
        return `option<` + generateType(schema._0) + `>`;
      case "Object" :
        return generateRecord(schema._0);
      case "Array" :
        return `array<` + generateType(schema._0) + `>`;
      case "Ref" :
        return lcFirst(schema._0);
      case "Enum" :
        let variants = schema._0.map(v => `#` + v).join(" | ");
        return `[` + variants + `]`;
      case "PolyVariant" :
        return generatePolyVariant(schema._0);
      case "Dict" :
        return `Dict.t<` + generateType(schema._0) + `>`;
      case "Union" :
        return generateUnion(schema._0);
    }
  }
}

function generateRecord(fields) {
  if (fields.length === 0) {
    return "{}";
  }
  let fieldStrs = fields.map(field => {
    let typeStr = generateType(field.type);
    let optionalType = field.required ? typeStr : `option<` + typeStr + `>`;
    return field.name + `: ` + optionalType;
  });
  return `{\n  ` + fieldStrs.join(",\n  ") + `\n}`;
}

function generatePolyVariant(cases) {
  let caseStrs = cases.map(c => {
    let payloadStr = generateType(c.payload);
    return `#` + c._tag + `(` + payloadStr + `)`;
  });
  return `[` + caseStrs.join(" | ") + `]`;
}

function ucFirst(s) {
  if (s.length === 0) {
    return s;
  }
  let first = s.charAt(0).toUpperCase();
  let rest = s.slice(1);
  return first + rest;
}

function generateUnion(types) {
  let caseStrs = types.map(t => {
    if (typeof t === "object" && t._tag === "Ref") {
      let name = t._0;
      let tag = ucFirst(name);
      let payload = lcFirst(name);
      return `#` + tag + `(` + payload + `)`;
    }
    let typeStr = generateType(t);
    return `#Value(` + typeStr + `)`;
  });
  return `[` + caseStrs.join(" | ") + `]`;
}

function generateTypeDef(namedSchema) {
  let typeName = lcFirst(namedSchema.name);
  let typeBody = generateType(namedSchema.schema);
  return `type ` + typeName + ` = ` + typeBody;
}

function generateModule(schemas) {
  let typeDefs = schemas.map(generateTypeDef);
  return typeDefs.join("\n\n");
}

export {
  lcFirst,
  generateType,
  generateRecord,
  generatePolyVariant,
  ucFirst,
  generateUnion,
  generateTypeDef,
  generateModule,
}
/* No side effect */
