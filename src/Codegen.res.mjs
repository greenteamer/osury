// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

let reservedKeywords = [
  "type",
  "let",
  "rec",
  "and",
  "as",
  "open",
  "include",
  "module",
  "sig",
  "struct",
  "exception",
  "external",
  "if",
  "else",
  "switch",
  "while",
  "for",
  "try",
  "catch",
  "when",
  "true",
  "false",
  "assert",
  "lazy",
  "constraint",
  "functor",
  "class",
  "method",
  "object",
  "private",
  "public",
  "virtual",
  "mutable",
  "new",
  "inherit",
  "initializer",
  "val",
  "with",
  "match",
  "of",
  "fun",
  "function",
  "in",
  "do",
  "done",
  "begin",
  "end",
  "then",
  "to",
  "downto",
  "or",
  "land",
  "lor",
  "lxor",
  "lsl",
  "lsr",
  "asr",
  "mod",
  "await",
  "async"
];

function isReservedKeyword(name) {
  return reservedKeywords.includes(name);
}

function lcFirst(s) {
  if (s.length === 0) {
    return s;
  }
  let first = s.charAt(0).toLowerCase();
  let rest = s.slice(1);
  return first + rest;
}

function generateType(schema) {
  if (typeof schema !== "object") {
    switch (schema) {
      case "String" :
        return "string";
      case "Number" :
        return "float";
      case "Integer" :
        return "int";
      case "Boolean" :
        return "bool";
      case "Null" :
        return "unit";
    }
  } else {
    switch (schema._tag) {
      case "Optional" :
        return `option<` + generateType(schema._0) + `>`;
      case "Nullable" :
        return `Nullable.t<` + generateType(schema._0) + `>`;
      case "Object" :
        return generateRecord(schema._0);
      case "Array" :
        return `array<` + generateType(schema._0) + `>`;
      case "Ref" :
        return lcFirst(schema._0);
      case "Enum" :
        let variants = schema._0.map(v => `#` + v).join(" | ");
        return `[` + variants + `]`;
      case "PolyVariant" :
        return generatePolyVariant(schema._0);
      case "Dict" :
        return `Dict.t<` + generateType(schema._0) + `>`;
      case "Union" :
        return generateUnion(schema._0);
    }
  }
}

function generatePolyVariant(cases) {
  let caseStrs = cases.map(c => {
    let payloadStr = generateType(c.payload);
    return `#` + c._tag + `(` + payloadStr + `)`;
  });
  return `[` + caseStrs.join(" | ") + `]`;
}

function generateRecord(fields) {
  if (fields.length === 0) {
    return "{}";
  }
  let fieldStrs = fields.map(field => {
    let typeStr = generateType(field.type);
    let optionalType = field.required || isOptionalType(field.type) ? typeStr : `option<` + typeStr + `>`;
    let asAttr = reservedKeywords.includes(field.name) ? `@as("` + field.name + `") ` : "";
    let fieldName = reservedKeywords.includes(field.name) ? field.name + `_` : field.name;
    return asAttr + fieldName + `: ` + optionalType;
  });
  return `{\n  ` + fieldStrs.join(",\n  ") + `\n}`;
}

function generateUnion(types) {
  let caseStrs = types.map(t => {
    let tag = getTagForType(t);
    let payload = generateType(t);
    return `#` + tag + `(` + payload + `)`;
  });
  return `[` + caseStrs.join(" | ") + `]`;
}

function getTagForType(t) {
  if (typeof t !== "object") {
    switch (t) {
      case "String" :
        return "String";
      case "Number" :
        return "Float";
      case "Integer" :
        return "Int";
      case "Boolean" :
        return "Bool";
      case "Null" :
        return "Null";
    }
  } else {
    switch (t._tag) {
      case "Optional" :
        return `Option` + getTagForType(t._0);
      case "Nullable" :
        return `Null` + getTagForType(t._0);
      case "Object" :
        return "Object";
      case "Array" :
        return `Array` + getTagForType(t._0);
      case "Ref" :
        return ucFirst(t._0);
      case "Enum" :
        return "Enum";
      case "PolyVariant" :
        return "Variant";
      case "Dict" :
        return "Dict";
      case "Union" :
        return "Union";
    }
  }
}

function ucFirst(s) {
  if (s.length === 0) {
    return s;
  }
  let first = s.charAt(0).toUpperCase();
  let rest = s.slice(1);
  return first + rest;
}

function isOptionalType(schema) {
  if (typeof schema !== "object") {
    return false;
  }
  switch (schema._tag) {
    case "Optional" :
    case "Nullable" :
      return true;
    default:
      return false;
  }
}

function isNullableType(schema) {
  if (typeof schema !== "object") {
    return false;
  } else {
    return schema._tag === "Nullable";
  }
}

function hasUnion(_schema) {
  while (true) {
    let schema = _schema;
    if (typeof schema !== "object") {
      return false;
    }
    switch (schema._tag) {
      case "Object" :
        return schema._0.some(f => hasUnion(f.type));
      case "PolyVariant" :
        return schema._0.some(c => hasUnion(c.payload));
      case "Optional" :
      case "Nullable" :
      case "Array" :
      case "Dict" :
        _schema = schema._0;
        continue;
      case "Union" :
        return true;
      default:
        return false;
    }
  };
}

function isPrimitiveOnlyUnion(types) {
  return types.every(t => {
    if (typeof t === "object") {
      return false;
    }
    switch (t) {
      case "String" :
      case "Number" :
      case "Integer" :
      case "Boolean" :
        return true;
      default:
        return false;
    }
  });
}

function generateInlineRecord(refName, schemasDict) {
  let other = schemasDict[refName];
  if (other !== undefined) {
    if (typeof other !== "object" || other._tag !== "Object") {
      return generateType(other);
    } else {
      return generateRecord(other._0);
    }
  } else {
    return lcFirst(refName);
  }
}

function generateInlineVariantBody(types, schemasDict, tagsDict) {
  return types.map(t => {
    if (typeof t === "object" && t._tag === "Ref") {
      let name = t._0;
      let tagValue = tagsDict[name];
      let tag = tagValue !== undefined ? ucFirst(tagValue) : ucFirst(name);
      let inlineRecord = generateInlineRecord(name, schemasDict);
      return tag + `(` + inlineRecord + `)`;
    }
    let tag$1 = getTagForType(t);
    let payload = generateType(t);
    return tag$1 + `(` + payload + `)`;
  }).join(" | ");
}

function isRefPlusDictUnion(types) {
  if (types.length !== 2) {
    return;
  }
  let hasDict = types.some(t => {
    if (typeof t !== "object") {
      return false;
    }
    if (t._tag !== "Dict") {
      return false;
    }
    let tmp = t._0;
    if (typeof tmp !== "object") {
      return tmp === "String";
    } else {
      return false;
    }
  });
  let refName = Core__Array.findMap(types, t => {
    if (typeof t !== "object" || t._tag !== "Ref") {
      return;
    } else {
      return t._0;
    }
  });
  if (hasDict) {
    return refName;
  }
}

function isPrimitivePlusDictUnion(types) {
  if (types.length !== 2) {
    return;
  }
  let hasDict = types.some(t => {
    if (typeof t !== "object") {
      return false;
    }
    if (t._tag !== "Dict") {
      return false;
    }
    let tmp = t._0;
    if (typeof tmp !== "object") {
      return tmp === "String";
    } else {
      return false;
    }
  });
  let primitiveName = Core__Array.findMap(types, t => {
    if (typeof t === "object") {
      return;
    }
    switch (t) {
      case "String" :
        return "string";
      case "Number" :
        return "float";
      case "Integer" :
        return "int";
      case "Boolean" :
        return "bool";
      default:
        return;
    }
  });
  if (hasDict) {
    return primitiveName;
  }
}

function getUnionName(types) {
  let names = types.map(t => {
    if (typeof t !== "object") {
      switch (t) {
        case "String" :
          return "string";
        case "Number" :
          return "float";
        case "Integer" :
          return "int";
        case "Boolean" :
          return "bool";
        case "Null" :
          return "null";
      }
    } else {
      switch (t._tag) {
        case "Array" :
          return "array";
        case "Ref" :
          return lcFirst(t._0);
        case "Dict" :
          return "dict";
        default:
          return "unknown";
      }
    }
  });
  if (names.length === 0) {
    return "emptyUnion";
  }
  let first = Core__Option.getOr(names[0], "unknown");
  let rest = names.slice(1);
  return first + rest.map(n => "Or" + ucFirst(n)).join("");
}

function extractUnionsFromType(_schema) {
  while (true) {
    let schema = _schema;
    if (typeof schema !== "object") {
      return [];
    }
    switch (schema._tag) {
      case "Object" :
        return schema._0.flatMap(field => extractUnionsFromType(field.type));
      case "Optional" :
      case "Nullable" :
      case "Array" :
      case "Dict" :
        _schema = schema._0;
        continue;
      case "Union" :
        let types = schema._0;
        let match = isRefPlusDictUnion(types);
        if (match !== undefined) {
          return [];
        }
        let name = getUnionName(types);
        return [{
            name: name,
            schema: schema
          }];
      default:
        return [];
    }
  };
}

function extractUnions(_parentName, schema) {
  if (typeof schema !== "object") {
    return [];
  } else if (schema._tag === "Object") {
    return schema._0.flatMap(field => extractUnionsFromType(field.type));
  } else {
    return [];
  }
}

function replaceUnionInType(schema) {
  if (typeof schema !== "object") {
    return schema;
  }
  switch (schema._tag) {
    case "Optional" :
      return {
        _tag: "Optional",
        _0: replaceUnionInType(schema._0)
      };
    case "Nullable" :
      return {
        _tag: "Nullable",
        _0: replaceUnionInType(schema._0)
      };
    case "Object" :
      let newFields = schema._0.map(field => {
        let newType = replaceUnionInType(field.type);
        return {
          name: field.name,
          type: newType,
          required: field.required
        };
      });
      return {
        _tag: "Object",
        _0: newFields
      };
    case "Array" :
      return {
        _tag: "Array",
        _0: replaceUnionInType(schema._0)
      };
    case "Dict" :
      return {
        _tag: "Dict",
        _0: replaceUnionInType(schema._0)
      };
    case "Union" :
      let types = schema._0;
      let refName = isRefPlusDictUnion(types);
      if (refName !== undefined) {
        return {
          _tag: "Ref",
          _0: refName
        };
      } else {
        return {
          _tag: "Ref",
          _0: getUnionName(types)
        };
      }
    default:
      return schema;
  }
}

function replaceUnions(_parentName, schema) {
  if (typeof schema !== "object") {
    return schema;
  }
  if (schema._tag !== "Object") {
    return schema;
  }
  let newFields = schema._0.map(field => {
    let newType = replaceUnionInType(field.type);
    return {
      name: field.name,
      type: newType,
      required: field.required
    };
  });
  return {
    _tag: "Object",
    _0: newFields
  };
}

function getDependencies(_schema) {
  while (true) {
    let schema = _schema;
    if (typeof schema !== "object") {
      return [];
    }
    switch (schema._tag) {
      case "Object" :
        return schema._0.flatMap(f => getDependencies(f.type));
      case "Ref" :
        return [schema._0];
      case "Enum" :
        return [];
      case "PolyVariant" :
        return schema._0.flatMap(c => getDependencies(c.payload));
      case "Optional" :
      case "Nullable" :
      case "Array" :
      case "Dict" :
        _schema = schema._0;
        continue;
      case "Union" :
        return schema._0.flatMap(getDependencies);
    }
  };
}

function topologicalSort(schemas) {
  let schemaMap = {};
  schemas.forEach(s => {
    schemaMap[s.name] = s;
  });
  let deps = {};
  schemas.forEach(s => {
    let refNames = getDependencies(s.schema);
    let validRefs = refNames.filter(name => Core__Option.isSome(schemaMap[name]));
    deps[s.name] = validRefs;
  });
  let outDegree = {};
  schemas.forEach(s => {
    let myDeps = Core__Option.getOr(deps[s.name], []);
    outDegree[s.name] = myDeps.length;
  });
  let reverseDeps = {};
  schemas.forEach(s => {
    reverseDeps[s.name] = [];
  });
  Object.entries(deps).forEach(param => {
    let name = param[0];
    param[1].forEach(refName => {
      let arr = reverseDeps[refName];
      if (arr !== undefined) {
        arr.push(name);
        return;
      }
    });
  });
  let queue = schemas.filter(s => Core__Option.getOr(outDegree[s.name], 0) === 0).map(s => s.name);
  let result = [];
  let visited = {};
  let process = () => {
    while (true) {
      let name = queue.shift();
      if (name === undefined) {
        return;
      }
      if (Core__Option.isNone(visited[name])) {
        visited[name] = true;
        let schema = schemaMap[name];
        if (schema !== undefined) {
          result.push(schema);
        }
        let dependents = reverseDeps[name];
        if (dependents !== undefined) {
          dependents.forEach(depName => {
            let current = Core__Option.getOr(outDegree[depName], 0);
            outDegree[depName] = current - 1 | 0;
            if ((current - 1 | 0) === 0) {
              queue.push(depName);
              return;
            }
          });
        }
      }
      continue;
    };
  };
  process();
  schemas.forEach(s => {
    if (Core__Option.isNone(visited[s.name])) {
      result.push(s);
      return;
    }
  });
  return result;
}

function buildSkipSchemaSet(schemas) {
  let skipSet = {};
  schemas.forEach(s => {
    if (hasUnion(s.schema)) {
      skipSet[s.name] = true;
      return;
    }
  });
  let changed = {
    contents: true
  };
  while (changed.contents) {
    changed.contents = false;
    schemas.forEach(s => {
      if (!Core__Option.isNone(skipSet[s.name])) {
        return;
      }
      let refs = getDependencies(s.schema);
      let refsSkipSchema = refs.some(refName => Core__Option.isSome(skipSet[refName]));
      if (refsSkipSchema) {
        skipSet[s.name] = true;
        changed.contents = true;
        return;
      }
    });
  };
  return skipSet;
}

function generateVariantBody(types) {
  return types.map(t => {
    let tag = getTagForType(t);
    let payload = generateType(t);
    return tag + `(` + payload + `)`;
  }).join(" | ");
}

function generateTypeDefWithSkipSet(namedSchema, _skipSet, schemasDict, tagsDict) {
  let typeName = lcFirst(namedSchema.name);
  let types = namedSchema.schema;
  if (typeof types === "object" && types._tag === "Union") {
    let types$1 = types._0;
    if (isPrimitiveOnlyUnion(types$1)) {
      let variantBody = generateVariantBody(types$1);
      return `@genType
@tag("_tag")
@unboxed
@schema
type ` + typeName + ` = ` + variantBody;
    }
    let variantBody$1 = generateInlineVariantBody(types$1, schemasDict, tagsDict);
    return `@genType
@tag("_tag")
@schema
type ` + typeName + ` = ` + variantBody$1;
  }
  let typeBody = generateType(namedSchema.schema);
  return `@genType
@schema
type ` + typeName + ` = ` + typeBody;
}

function generateTypeDef(namedSchema) {
  let typeName = lcFirst(namedSchema.name);
  let types = namedSchema.schema;
  if (typeof types === "object" && types._tag === "Union") {
    let variantBody = generateVariantBody(types._0);
    return `@genType
@tag("_tag")
@unboxed
@schema
type ` + typeName + ` = ` + variantBody;
  }
  let annotations = hasUnion(namedSchema.schema) ? "@genType" : "@genType\n@schema";
  let typeBody = generateType(namedSchema.schema);
  return annotations + `
type ` + typeName + ` = ` + typeBody;
}

function collectUnionWarnings(schemas) {
  let seen = {};
  let warnings = [];
  let findUnions = _schema => {
    while (true) {
      let schema = _schema;
      if (typeof schema !== "object") {
        return [];
      }
      switch (schema._tag) {
        case "Object" :
          return schema._0.flatMap(f => findUnions(f.type));
        case "Optional" :
        case "Nullable" :
        case "Array" :
        case "Dict" :
          _schema = schema._0;
          continue;
        case "Union" :
          return [schema._0];
        default:
          return [];
      }
    };
  };
  schemas.forEach(s => {
    let unions = findUnions(s.schema);
    unions.forEach(types => {
      let unionName = getUnionName(types);
      if (!Core__Option.isNone(seen[unionName])) {
        return;
      }
      seen[unionName] = true;
      let refName = isRefPlusDictUnion(types);
      if (refName !== undefined) {
        warnings.push(`⚠ ` + unionName + `: anyOf without discriminator, simplified to ` + lcFirst(refName));
        return;
      }
      let primName = isPrimitivePlusDictUnion(types);
      if (primName !== undefined) {
        warnings.push(`⚠ ` + unionName + `: anyOf [` + primName + `, Dict] without discriminator, @tag("_tag") may not work at runtime`);
        return;
      }
    });
  });
  return warnings;
}

function generateModule(schemas) {
  let warnings = collectUnionWarnings(schemas);
  warnings.forEach(w => {
    console.log(w);
  });
  let extractedUnions = schemas.flatMap(s => extractUnions(s.name, s.schema).map(extracted => ({
    name: extracted.name,
    schema: extracted.schema,
    discriminatorTag: undefined
  })));
  let seen = {};
  let uniqueUnions = extractedUnions.filter(u => {
    if (Core__Option.isSome(seen[u.name])) {
      return false;
    } else {
      seen[u.name] = true;
      return true;
    }
  });
  let modifiedSchemas = schemas.map(s => ({
    name: s.name,
    schema: replaceUnions(s.name, s.schema),
    discriminatorTag: s.discriminatorTag
  }));
  let allSchemas = uniqueUnions.concat(modifiedSchemas);
  let schemasDict = {};
  let tagsDict = {};
  allSchemas.forEach(s => {
    schemasDict[s.name] = s.schema;
    let tag = s.discriminatorTag;
    if (tag !== undefined) {
      tagsDict[s.name] = tag;
      return;
    }
  });
  let sorted = topologicalSort(allSchemas);
  let skipSet = {};
  let typeDefs = sorted.map(s => generateTypeDefWithSkipSet(s, skipSet, schemasDict, tagsDict)).join("\n\n");
  return "module S = Sury\n\n" + typeDefs;
}

function generateDictShim() {
  return `// Generated by osury - Dict type shim for @genType
export type t<T> = { [key: string]: T };
`;
}

function generateNullableShim() {
  return `// Generated by osury - Nullable type shim for @genType
export type t<T> = T | null;
`;
}

function generateNullableModule() {
  return `// Generated by osury - Nullable type for JSON Schema null support
// Maps to T | null in TypeScript (not T | undefined like option<T>)

@genType.import(("./Nullable.gen.ts", "t"))
type t<'a> = option<'a>
`;
}

export {
  reservedKeywords,
  isReservedKeyword,
  lcFirst,
  generateType,
  isOptionalType,
  isNullableType,
  generateRecord,
  generatePolyVariant,
  ucFirst,
  getTagForType,
  generateUnion,
  hasUnion,
  isPrimitiveOnlyUnion,
  generateInlineRecord,
  generateInlineVariantBody,
  isRefPlusDictUnion,
  isPrimitivePlusDictUnion,
  getUnionName,
  extractUnions,
  extractUnionsFromType,
  replaceUnions,
  replaceUnionInType,
  getDependencies,
  topologicalSort,
  buildSkipSchemaSet,
  generateVariantBody,
  generateTypeDefWithSkipSet,
  generateTypeDef,
  collectUnionWarnings,
  generateModule,
  generateDictShim,
  generateNullableShim,
  generateNullableModule,
}
/* No side effect */
